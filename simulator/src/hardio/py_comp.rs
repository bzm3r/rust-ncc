use crate::parameters::quantity::Quantity;
use crate::parameters::{
    CharacteristicQuantities, Parameters, WorldParameters,
};
use crate::NVERTS;
use serde::{Deserialize, Serialize};
use std::fs::{create_dir_all, OpenOptions};
use std::path::PathBuf;
use tracing::info;

/// A combination of `parameters::CharQuants`, `parameters:WorldParameters`,
/// `parameters::PhysicalContactParameters`,`parameters::CoaParameters`.
/// and`parameters::Parameters`. However, some types are simplified (e.g.
/// types representing quantities are turned to `f64`). Meant for comparison
/// with output generated by Python model.
#[derive(Clone, Deserialize, Serialize, Default, Debug, PartialEq)]
pub struct Header {
    pub num_tsteps: usize,
    pub num_int_steps: usize,
    pub num_cells: usize,
    pub eta: f64,
    pub f: f64,
    pub l: f64,
    pub t: f64,
    pub l3d: f64,
    pub k_mem_on_vertex: f64,
    pub k_mem_off: f64,
    pub kgtp: f64,
    pub close_zero_at: f64,
    pub close_one_at: f64,
    pub cil_mag: f64,
    pub coa_los_penalty: f64,
    pub coa_halfmax_dist: f64,
    pub coa_distrib_exp: f64,
    pub coa_mag: f64,
    pub vertex_eta: f64,
    pub cell_r: f64,
    pub rest_edge_len: f64,
    pub rest_area: f64,
    pub stiffness_edge: f64,
    pub const_protrusive: f64,
    pub const_retractive: f64,
    pub stiffness_cyto: f64,
    pub diffusion_rgtp: f64,
    /// Simplified from `parameters::Parameters`, where it is `RgtpDistribution`.
    pub init_rac: [f64; NVERTS],
    /// Simplified from `parameters::Parameters`, where it is `RgtpDistribution`.
    pub init_rho: [f64; NVERTS],
    pub halfmax_vertex_rgtp_act: f64,
    pub halfmax_vertex_rgtp_conc: f64,
    pub kgtp_rac: f64,
    pub kgtp_rac_auto: f64,
    pub kdgtp_rac: f64,
    pub kdgtp_rho_on_rac: f64,
    pub halfmax_tension_inhib: f64,
    pub tension_inhib: f64,
    pub kgtp_rho: f64,
    pub kgtp_rho_auto: f64,
    pub kdgtp_rho: f64,
    pub kdgtp_rac_on_rho: f64,
    pub randomization: bool,
    pub rand_avg_t: f64,
    pub rand_std_t: f64,
    pub rand_mag: f64,
    pub num_rand_vs: u32,
}

/// Stores data generated in intermediate integration steps.
#[derive(Clone, Deserialize, Serialize, Default, Debug, PartialEq)]
pub struct IntStepData {
    pub poly: Vec<[f64; 2]>,
    pub rac_acts: [f64; NVERTS],
    pub rac_inacts: [f64; NVERTS],
    pub rho_acts: [f64; NVERTS],
    pub rho_inacts: [f64; NVERTS],
    pub sum_forces: Vec<[f64; 2]>,
    pub uivs: Vec<[f64; 2]>,
    pub kgtps_rac: [f64; NVERTS],
    pub kdgtps_rac: [f64; NVERTS],
    pub kgtps_rho: [f64; NVERTS],
    pub kdgtps_rho: [f64; NVERTS],
    pub rgtp_forces: Vec<[f64; 2]>,
    pub edge_forces: Vec<[f64; 2]>,
    pub cyto_forces: Vec<[f64; 2]>,
    pub x_cils: [f64; NVERTS],
    pub x_coas: [f64; NVERTS],
    pub rac_act_net_fluxes: [f64; NVERTS],
    pub edge_strains: [f64; NVERTS],
    pub poly_area: f64,
    pub coa_updates: [bool; NVERTS],
    pub cil_updates: [bool; NVERTS],
    pub uevs: Vec<[f64; 2]>,
}

#[derive(Clone, Deserialize, Serialize, Default, Debug, PartialEq)]
pub struct CellData {
    int_steps: Vec<IntStepData>,
}

impl CellData {
    pub fn save(&mut self, max_int_steps: usize, int_step: IntStepData) {
        if self.int_steps.len() >= max_int_steps {
            panic!("cannot save int step, already have {} int steps stored (max: {})",
                   self.int_steps.len(),
                   max_int_steps
            )
        } else {
            self.int_steps.push(int_step);
        }
    }
}

#[derive(Clone, Deserialize, Serialize, Default, Debug, PartialEq)]
pub struct StepData {
    cells: Vec<CellData>,
}

impl StepData {
    pub fn save(&mut self, max_cells: usize, cell_data: CellData) {
        if self.cells.len() >= max_cells {
            panic!(
                "cannot save cell, already have {} cells stored (max: {})",
                self.cells.len(),
                max_cells
            )
        } else {
            self.cells.push(cell_data);
        }
    }
}

#[derive(Clone, Deserialize, Serialize, Default, Debug, PartialEq)]
pub struct SimulationData {
    header: Header,
    pub tsteps: Vec<StepData>,
}

#[derive(Default)]
pub struct Writer {
    out_dir: PathBuf,
    file_name: PathBuf,
    pub data: SimulationData,
    curr_step_data: StepData,
    curr_cell_data: CellData,
    curr_int_step_ix: usize,
    curr_cell_ix: usize,
    pub num_tsteps: usize,
    pub num_int_steps: usize,
    pub num_cells: usize,
    pub finished: bool,
    pub can_save_cell: bool,
    pub can_save_int_step: bool,
}

impl Writer {
    pub fn init(
        &mut self,
        out_dir: PathBuf,
        final_t: f64,
        num_tsteps: usize,
        num_int_steps: usize,
        num_cells: usize,
        cil_mag: u32,
        coa_mag: u32,
    ) -> Writer {
        let out_dir: PathBuf =
            [out_dir, PathBuf::from("rust")].iter().collect();
        let file_name: PathBuf = PathBuf::from(format!(
            "out_euler_T={}_E={}_NC={}_CIL={}_COA={}.dat",
            final_t, num_int_steps, num_cells, cil_mag, coa_mag
        ));
        Writer {
            num_tsteps,
            num_int_steps,
            num_cells,
            out_dir,
            file_name,
            data: SimulationData::default(),
            curr_cell_data: CellData::default(),
            curr_step_data: StepData::default(),
            curr_int_step_ix: 0,
            curr_cell_ix: 0,
            can_save_cell: false,
            can_save_int_step: false,
            finished: false,
        }
    }

    pub fn begin_cell_save(&mut self) {
        match (
            self.curr_cell_ix < self.num_cells,
            self.curr_int_step_ix == 0,
        ) {
            (true, true) => {
                self.can_save_int_step = true;
            }
            (_, _) => {
                panic!(
                    "cannot begin cell save: curr_cell = {} (max: {}), \
                curr_int_step = {} (max: {})",
                    self.curr_cell_ix,
                    self.num_cells,
                    self.curr_int_step_ix,
                    self.num_int_steps
                )
            }
        }
    }

    pub fn save_int_step(&mut self, int_step: IntStepData) {
        if self.can_save_int_step {
            self.curr_cell_data.save(self.num_int_steps, int_step);
            self.curr_int_step_ix += 1;
        } else {
            panic!("can_save_int_step is false");
        }
    }

    pub fn finish_cell_save(&mut self) {
        if self.curr_int_step_ix == self.num_int_steps {
            self.can_save_int_step = false;
            if self.can_save_cell {
                self.curr_step_data
                    .save(self.num_cells, self.curr_cell_data.clone());
                self.curr_cell_ix += 1;
            } else {
                panic!("can_save_cell is false");
            }
            self.curr_cell_data = CellData::default();
            self.curr_int_step_ix = 0;
        } else {
            panic!("cannot finish cell save; only have {} int steps (required: {})",
                   self.curr_int_step_ix, self.num_int_steps)
        }
    }

    pub fn begin_tstep_save(&mut self) {
        match (
            self.data.tsteps.len() < self.num_tsteps,
            self.curr_cell_ix == 0,
            self.curr_int_step_ix == 0,
        ) {
            (true, true, true) => {
                self.can_save_cell = true;
            }
            (_, _, _) => {
                panic!(
                    "cannot begin cell save: curr_cell = {} (max: {}), \
                curr_int_step = {} (max: {})",
                    self.curr_cell_ix,
                    self.num_cells,
                    self.curr_int_step_ix,
                    self.num_int_steps
                )
            }
        }
    }

    pub fn finish_tstep_save(&mut self) {
        if self.curr_cell_ix == self.num_cells {
            if self.can_save_int_step || self.curr_int_step_ix > 0 {
                panic!("cannot finish tstep: int step saving has not been finished (can still \
                save more int steps in current cell)");
            } else {
                self.can_save_cell = false;
                self.curr_cell_ix = 0;
                self.data.tsteps.push(self.curr_step_data.clone());
                self.curr_step_data = StepData::default();
            }
        } else {
            panic!(
                "cannot finish tstep save; only have {} cells (required: {})",
                self.curr_cell_ix, self.num_cells
            )
        }
    }

    pub fn finish(&mut self) {
        if self.can_save_int_step {
            panic!("cannot finish; int step saving has not been finished (can still save more \
            int steps into current cell)")
        }
        if self.can_save_cell {
            panic!("cannot finish; tstep saving has not been finished (can still save more cells \
            into current step)")
        }
        if self.data.tsteps.len() < self.num_tsteps {
            panic!(
                "cannot finish; only have {} tsteps (required: {})",
                self.data.tsteps.len(),
                self.num_tsteps
            )
        }
        create_dir_all(&self.out_dir).unwrap();
        let file_path: PathBuf = [self.out_dir.clone(), self.file_name.clone()]
            .iter()
            .collect();
        info!("saving to: {}", &file_path.to_str().unwrap());
        let mut f = OpenOptions::new()
            .create(true)
            .truncate(true)
            .write(true)
            .open(&file_path)
            .unwrap();

        serde_json::to_writer(&mut f, &self.data).unwrap();
        self.finished = true;
    }

    pub fn save_header(
        &mut self,
        char_quants: &CharacteristicQuantities,
        world_params: &WorldParameters,
        params: &Parameters,
    ) {
        self.data.header = Header {
            num_tsteps: self.num_tsteps,
            num_int_steps: self.num_int_steps,
            num_cells: self.num_cells,
            eta: char_quants.eta.number(),
            f: char_quants.f.number(),
            l: char_quants.l.number(),
            t: char_quants.t.number(),
            l3d: char_quants.l3d.number(),
            k_mem_off: params.k_mem_off,
            k_mem_on_vertex: params.k_mem_on_vertex,
            kgtp: char_quants.kgtp.number(),
            close_zero_at: world_params.interactions.phys_contact.zero_at,
            close_one_at: world_params.interactions.phys_contact.crl_one_at,
            cil_mag: world_params.interactions.phys_contact.cil_mag,
            coa_los_penalty: world_params
                .interactions
                .coa
                .as_ref()
                .map_or_else(|| 0.0, |coa_gen| coa_gen.los_penalty),
            coa_halfmax_dist: world_params
                .interactions
                .coa
                .as_ref()
                .map_or_else(|| 0.0, |coa_gen| coa_gen.halfmax_dist),
            coa_distrib_exp: world_params
                .interactions
                .coa
                .as_ref()
                .map_or_else(|| 0.0, |coa_gen| coa_gen.distrib_exp),
            coa_mag: world_params
                .interactions
                .coa
                .as_ref()
                .map_or_else(|| 0.0, |coa_gen| coa_gen.vertex_mag),
            vertex_eta: world_params.vertex_eta,
            cell_r: params.cell_r,
            rest_edge_len: params.rest_edge_len,
            rest_area: params.rest_area,
            stiffness_edge: params.stiffness_edge,
            const_protrusive: params.const_protrusive,
            const_retractive: params.const_retractive,
            stiffness_cyto: params.stiffness_cyto,
            diffusion_rgtp: params.diffusion_rgtp,
            init_rac: params.init_rac.active,
            init_rho: params.init_rho.active,
            halfmax_vertex_rgtp_act: params.halfmax_vertex_rgtp,
            halfmax_vertex_rgtp_conc: params.halfmax_vertex_rgtp_conc,
            kgtp_rac: params.kgtp_rac,
            kgtp_rac_auto: params.kgtp_rac_auto,
            kdgtp_rac: params.kdgtp_rac,
            kdgtp_rho_on_rac: params.kdgtp_rho_on_rac,
            halfmax_tension_inhib: params.halfmax_tension_inhib,
            tension_inhib: params.tension_inhib,
            kgtp_rho: params.kgtp_rho,
            kgtp_rho_auto: params.kgtp_rho_auto,
            kdgtp_rho: params.kdgtp_rho,
            kdgtp_rac_on_rho: params.kdgtp_rac_on_rho,
            randomization: false,
            rand_avg_t: params.rand_avg_t,
            rand_std_t: params.rand_std_t,
            rand_mag: params.rand_mag,
            num_rand_vs: params.num_rand_vs,
        };
    }
}
